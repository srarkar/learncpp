/*
Local Variables
    Variables declared inside the body of a function are called local variables. This includes function parameters.
    A variable's lifetime is the time between its creation and destruction.

Destruction
    In most cases, after destruction, the object simply becomes invalid. Any use of it after this point is undefined behavior.
    For a class type object, prior to destruction, a special function called a destructor is invoked
        In some cases, the destructor may do nothing
    After destruction, the memory the object was occupying is deallocated/freed.

Scope
    An identifier's scope dictates where the identifier can be seen and used within source code. 
    An identifier that can be seen and used is in-scope (as opposed to out-of-scope). 
    An identifier with local scope (aka block scope) is usable from the point of definition to the end of the innermost pair of curly braces
        containing the identifier (or for function parameters, at the end of the function

    An identifier is "out of scope" anywhere it cannot be accessed within the code. 
        On the other hand, an object "goes out of scope" at the end curly-brace, or at the end of its scope
    A local variableâ€™s lifetime ends at the point where it goes out of scope, so local variables are destroyed at this point.

    It is important to note that lifetime is a runtime property, while scope is a compile-time property.
    Best practice dictates to define local variables as close to their first use as reasonably possible.
*/

/*
Temporary Objects
    When a value is only needed for a short amount of time, a temporary object (aka anonymous object) is generated by the compiler.
    Temporary objects have no scope, and cease to exist at the end of the expression. 
    There is room for optimizations in modern C++ compilers, where we avoid creating a temporary when using a return value to initialize a variable

*/
#include <iostream>

int add(int x, int y) // function parameters x and y are local variables, created when the function is entered after its call
{
    int z{ x + y }; // z is a local variable

    return z;
} // z, followed by x and y are destroyed here (in reverse order of their creation)

// x is not in scope anywhere in this function
void doSomething()
{
    std::cout << "Hello!\n";
}

int main()
{
    // x can not be used here because it's not in scope yet

    int x{ 0 }; // x enters scope here and can now be used within this function

    doSomething();

    // here, the return value of add is copied into a temporary object, since we did not provide a variable to store it in. 
    // this object is then passed into std::cout
    std::cout << add(1,2);

    return 0;
}